{"version":3,"sources":["src/typing.js","src/util.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1FA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhIA;AAAA","file":"dist/typing.js","sourcesContent":["'use strict';\n\nvar _util = require('./util');\n\n(function ($) {\n\t$.fn.typing = function (options) {\n\n\t\t// SETTINGS\n\t\tvar settings = {\n\t\t\tsentences: ['Hello', 'Try your own sentences!', 'Don\\'t be lazy'],\n\t\t\tcaretChar: '_',\n\t\t\tcaretClass: 'typingjs__caret',\n\n\t\t\tignoreContent: false,\n\t\t\tignoreSentence: false,\n\t\t\ttypeDelay: 50,\n\t\t\tsentenceDelay: 750,\n\t\t\thumanize: true,\n\n\t\t\tonType: undefined,\n\t\t\tonBackspace: undefined,\n\t\t\tonFinish: undefined,\n\t\t\tonSentenceFinish: undefined\n\t\t};\n\t\t$.extend(settings, options);\n\n\t\treturn this.each(function () {\n\n\t\t\t// Sets up element\n\t\t\tvar this_ = $(this);\n\t\t\tvar text = '';\n\t\t\tif (!settings.ignoreContent) {\n\t\t\t\ttext = this_.text();\n\t\t\t\tif (this_.children('.typingjs__content').length > 0) text = this_.children('.typingjs__content').text();\n\t\t\t}\n\n\t\t\tvar $content = $('<span>', { class: 'typingjs__content', text: text });\n\t\t\tvar $caret = $('<span>', { class: settings.caretClass, text: settings.caretChar });\n\n\t\t\tthis_.empty();\n\t\t\tthis_.append($content);\n\t\t\tthis_.append($caret);\n\n\t\t\t// Variable for sentences state\n\t\t\tvar sentencesLeft = settings.sentences;\n\n\t\t\tfunction typeSentence(typer) {\n\t\t\t\t// Reads next iteration of the typing animation.\n\t\t\t\tvar _typer = typer(),\n\t\t\t\t    current = _typer.current,\n\t\t\t\t    isType = _typer.isType,\n\t\t\t\t    isBackspace = _typer.isBackspace,\n\t\t\t\t    isDone = _typer.isDone;\n\n\t\t\t\t$content.text(current);\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tif ((0, _util.isFunction)(settings.onSentenceFinish)) settings.onSentenceFinish.call(this_);\n\t\t\t\t\ttypeArray();\n\t\t\t\t} else {\n\t\t\t\t\t// Callbacks.\n\t\t\t\t\tif (isType && (0, _util.isFunction)(settings.onType)) settings.onType.call(this_);\n\t\t\t\t\tif (isBackspace && (0, _util.isFunction)(settings.onBackspace)) settings.onBackspace.call(this_);\n\n\t\t\t\t\t// Next step\n\t\t\t\t\tvar humanTimeout = settings.typeDelay;\n\t\t\t\t\tif (settings.humanize) humanTimeout = (0, _util.noise)(settings.typeDelay, settings.typeDelay);\n\t\t\t\t\tsetTimeout(typeSentence, humanTimeout, typer);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction typeArray() {\n\t\t\t\tvar targetStr = (0, _util.head)(sentencesLeft);\n\t\t\t\tsentencesLeft = (0, _util.tail)(sentencesLeft);\n\t\t\t\tif (targetStr !== undefined) {\n\t\t\t\t\tvar typer = (0, _util.makePrefixTyper)($content.text(), targetStr);\n\t\t\t\t\tif (settings.ignoreSentence) {\n\t\t\t\t\t\ttyper = (0, _util.makeTyper)($content.text(), targetStr, function (curr) {\n\t\t\t\t\t\t\treturn curr.length == 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(typeSentence, settings.sentenceDelay, typer);\n\t\t\t\t} else if ((0, _util.isFunction)(settings.onFinish)) {\n\t\t\t\t\tsettings.onFinish.call(this_);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttypeArray();\n\t\t}); // each\n\t}; // function typing\n})(jQuery);\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.isFunction = isFunction;\nexports.isArray = isArray;\nexports.head = head;\nexports.tail = tail;\nexports.strTail = strTail;\nexports.strHead = strHead;\nexports.strLast = strLast;\nexports.strDrop = strDrop;\nexports.strDropTail = strDropTail;\nexports.strIntersect = strIntersect;\nexports.noise = noise;\nexports.isPrefix = isPrefix;\nexports.isEmpty = isEmpty;\nexports.makeTyper = makeTyper;\nexports.makePrefixTyper = makePrefixTyper;\n// Checks if the given object is a function. Taken from underscorejs source code.\nfunction isFunction(obj) {\n\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\n// Checks if the given object is an array.\nfunction isArray(obj) {\n\treturn toString(obj) === \"[object Array]\";\n}\n\n// Returns the first element of the array.\nfunction head(array) {\n\treturn array[0];\n}\n\n// Returns the same array skipping the first element.\nfunction tail(array) {\n\treturn array.slice(1);\n}\n\n// Drops the first character of the string and returns the rest.\nfunction strTail(str) {\n\treturn str.substring(1, str.length);\n}\n\n// Returns the first character of the string.\nfunction strHead(str) {\n\treturn str[0];\n}\n\n// Return the last character of the string.\nfunction strLast(str) {\n\treturn str[str.length - 1];\n}\n\n// Drops the given number of characters from the start of the string.\nfunction strDrop(string, n) {\n\treturn string.substr(n, string.length);\n}\n\n// Drops the given number of characters from the end of the string\nfunction strDropTail(string, n) {\n\treturn string.substr(0, string.length - n);\n}\n\n// Intersects the start of two strings.\nfunction strIntersect(a, b) {\n\tvar i;\n\tfor (i = 0; i < Math.min(a.length, b.length); i++) {\n\t\tif (a[i] != b[i]) break;\n\t}\n\treturn a.substr(0, i);\n}\n\n// Returns the original value with the given noise applied.\n// E.g. noise(x, 2) = x - 2 <= y <= x + 2\nfunction noise(x, delta) {\n\treturn Math.round(Math.random() * delta * 2 - delta) + x;\n}\n\n// Checks if the given prefix is prefix of target.\nfunction isPrefix(prefix, target) {\n\treturn target.substr(0, prefix.length) == prefix;\n}\n\n// Checks if the given string has length zero.\nfunction isEmpty(string) {\n\treturn string.length == 0;\n}\n\n// Creates a typer that deletes characters each time it\n// is called until predicate is true. After that, it appends\n// the characters of the given string one by one each time\n// it is called.\nfunction makeTyper(current, pending, predicate) {\n\tvar forward = current.length == 0;\n\tvar prevLength = current.length;\n\treturn function () {\n\t\tvar step = {\n\t\t\tcurrent: current,\n\t\t\tpending: pending,\n\t\t\tisType: current.length > prevLength,\n\t\t\tisBackspace: current.length < prevLength,\n\t\t\tisDone: forward && pending.length <= 0\n\t\t};\n\n\t\tprevLength = current.length;\n\t\tif (forward && pending.length > 0) {\n\t\t\tcurrent = current + head(pending);\n\t\t\tpending = tail(pending);\n\t\t} else if (!forward && current.length > 0) {\n\t\t\tcurrent = strDropTail(current, 1);\n\t\t}\n\t\tforward = forward || current.length == 0 || predicate(current, pending);\n\n\t\treturn step;\n\t};\n}\n\n// Creates a typer that deletes characters until current is a prefix\n// of target.\nfunction makePrefixTyper(current, target) {\n\tvar commonPrefix = strIntersect(current, target);\n\tvar pending = target.substr(commonPrefix.length, target.length);\n\treturn makeTyper(current, pending, function (curr) {\n\t\treturn curr == commonPrefix;\n\t});\n}\n"]}